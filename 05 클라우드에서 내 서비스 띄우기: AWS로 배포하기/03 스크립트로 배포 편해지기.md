# 스크립트로 배포 편해지기

## 배포 자동화 스크립트 작성

반복적인 배포 작업을 자동화하기 위한 스크립트를 작성하는 방법을 알아봅니다.

기본 배포 스크립트
```bash
#!/bin/bash

# 환경 변수 설정
export APP_NAME="your-app"
export DOCKER_IMAGE="your-docker-image"
export DOCKER_TAG="latest"

# 이전 컨테이너 정리
echo "Cleaning up old containers..."
docker stop $APP_NAME || true
docker rm $APP_NAME || true

# 새 이미지 가져오기
echo "Pulling new image..."
docker pull $DOCKER_IMAGE:$DOCKER_TAG

# 새 컨테이너 실행
echo "Starting new container..."
docker run -d \
  --name $APP_NAME \
  -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE=prod \
  $DOCKER_IMAGE:$DOCKER_TAG

echo "Deployment completed!"
```



환경 변수 설정 파일

```bash
# .env 파일
APP_NAME=your-app
DOCKER_IMAGE=your-docker-image
DOCKER_TAG=latest
SPRING_PROFILES_ACTIVE=prod
DB_HOST=localhost
DB_PORT=3306
DB_NAME=yourdb
DB_USER=user
DB_PASSWORD=password
```



## Docker Compose를 활용한 배포

Docker Compose를 사용하여 여러 서비스를 함께 배포하는 방법을 알아봅니다.

Docker Compose 파일 작성
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    image: ${DOCKER_IMAGE}:${DOCKER_TAG}
    container_name: ${APP_NAME}
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE}
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
    depends_on:
      - db
    restart: always

  db:
    image: mysql:8.0
    container_name: ${APP_NAME}-db
    environment:
      - MYSQL_DATABASE=${DB_NAME}
      - MYSQL_USER=${DB_USER}
      - MYSQL_PASSWORD=${DB_PASSWORD}
      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}
    volumes:
      - mysql-data:/var/lib/mysql
    ports:
      - "3306:3306"
    restart: always

volumes:
  mysql-data:
```



Docker Compose 배포 스크립트

```bash
#!/bin/bash

# 환경 변수 파일 로드
source .env

# 이전 컨테이너 정리
echo "Cleaning up old containers..."
docker-compose down

# 새 이미지 가져오기
echo "Pulling new images..."
docker-compose pull

# 서비스 시작
echo "Starting services..."
docker-compose up -d

echo "Deployment completed!"
```



## 서비스 시작/중지 스크립트

서비스를 쉽게 시작하고 중지할 수 있는 스크립트를 작성합니다.

서비스 관리 스크립트
```bash
#!/bin/bash

function start_services() {
  echo "Starting services..."
  docker-compose up -d
}

function stop_services() {
  echo "Stopping services..."
  docker-compose down
}

function restart_services() {
  echo "Restarting services..."
  docker-compose restart
}

function show_status() {
  echo "Service status:"
  docker-compose ps
}

case "$1" in
  start)
    start_services
    ;;
  stop)
    stop_services
    ;;
  restart)
    restart_services
    ;;
  status)
    show_status
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}"
    exit 1
    ;;
esac
```



## 로그 수집 및 모니터링

로그를 수집하고 모니터링하는 스크립트를 작성합니다.

로그 수집 스크립트
```bash
#!/bin/bash

# 로그 디렉토리 설정
LOG_DIR="/var/log/${APP_NAME}"
mkdir -p $LOG_DIR

# 로그 파일 이름 설정
LOG_FILE="$LOG_DIR/app.log"

# 로그 수집
docker logs -f $APP_NAME > $LOG_FILE 2>&1 &

# 로그 로테이션 (7일 이상 된 로그 삭제)
find $LOG_DIR -name "*.log" -mtime +7 -delete
```



모니터링 스크립트

```bash
#!/bin/bash

# 시스템 리소스 모니터링
function monitor_resources() {
  echo "CPU Usage:"
  docker stats --no-stream $APP_NAME --format "{{.CPUPerc}}"
  
  echo "Memory Usage:"
  docker stats --no-stream $APP_NAME --format "{{.MemUsage}}"
  
  echo "Network Usage:"
  docker stats --no-stream $APP_NAME --format "{{.NetIO}}"
}

# 주기적 모니터링
while true; do
  monitor_resources
  sleep 60
done
```



## 백업 및 복구 스크립트

데이터베이스와 설정 파일을 백업하고 복구하는 스크립트를 작성합니다.

백업 스크립트
```bash
#!/bin/bash

# 백업 디렉토리 설정
BACKUP_DIR="/backup/${APP_NAME}"
mkdir -p $BACKUP_DIR

# 백업 파일 이름 설정
BACKUP_FILE="$BACKUP_DIR/backup_$(date +%Y%m%d_%H%M%S).sql"

# 데이터베이스 백업
docker exec ${APP_NAME}-db mysqldump -u${DB_USER} -p${DB_PASSWORD} ${DB_NAME} > $BACKUP_FILE

# 오래된 백업 삭제 (30일 이상)
find $BACKUP_DIR -name "backup_*.sql" -mtime +30 -delete
```



복구 스크립트

```bash
#!/bin/bash

# 백업 파일 확인
if [ -z "$1" ]; then
  echo "Usage: $0 <backup_file>"
  exit 1
fi

BACKUP_FILE=$1

# 데이터베이스 복구
docker exec -i ${APP_NAME}-db mysql -u${DB_USER} -p${DB_PASSWORD} ${DB_NAME} < $BACKUP_FILE
```



## 알림 설정

배포 상태와 시스템 상태를 알림으로 받는 스크립트를 작성합니다.

Slack 알림 스크립트
```bash
#!/bin/bash

# Slack Webhook URL
SLACK_WEBHOOK="https://hooks.slack.com/services/your-webhook-url"

# 알림 전송 함수
function send_notification() {
  local message=$1
  curl -X POST -H 'Content-type: application/json' \
    --data "{\"text\":\"$message\"}" \
    $SLACK_WEBHOOK
}

# 배포 상태 알림
if [ $? -eq 0 ]; then
  send_notification "Deployment successful!"
else
  send_notification "Deployment failed!"
fi
```



